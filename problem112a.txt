まず以下をproblem112a.sとして保存した。


	.section ".rodata"
	.align 3
	# 返す初期値
fzero:
	.double 0.0
	.section ".text"
	.global dot
	.align 2
dot:
	# %r3にはnが入っているこれが0になるまでループする
	# まずは%f1に初期値をセット
	addis %r6, %r2, fzero@toc@ha
	addi %r6, %r6, fzero@toc@l
	lfd %f1, 0(%r6)
loop:
	# nが0ならば今の値を返す
	cmpwi %r3, 0
	beq ret
	# %f2と%f3に一つ目の値をロードする
	lfd %f2, 0(%r4)
	lfd %f3, 0(%r5)
	# 8バイト分アドレスを進めておく
	addi %r4, %r4, 8
	addi %r5, %r5, 8
	# 掛け算
	fmul %f2, %f2, %f3
	# 掛けたものを返り値に足す
	fadd %f1, %f1, %f2
	# %r3を一つ減らす
	subi %r3, %r3, 1
	b loop
ret:
	blr

そしてテスト用に以下のプログラムをproblem112a.cとして保存した。


#include <stdio.h>
#include <stdlib.h>

double dot(size_t n, const double v[], const double w[]);

int main() {
    printf("dot(2, &(double[]){-2.32, 23.3}, &(double[]){10.9, 2.5}) == %f\n", dot(2, &(double[]){-2.32, 23.3}, &(double[]){10.9, 2.5}));
    puts("ans 32.962");
    printf("dot(0, NULL, NULL) == %f\n", dot(0, NULL, NULL));
    puts("ans 0.0");
    printf("dot(6, &(double[]){0.0783, 4.57, 13.1, -5.45, 9.60, 9.07}, &(double[]){-5.85, 0.397, 2.11, 4.04, 2.20, -3.48}) == %f\n", dot(6, &(double[]){0.0783, 4.57, 13.1, -5.45, 9.60, 9.07}, &(double[]){-5.85, 0.397, 2.11, 4.04, 2.20, -3.48}));
    puts("ans -3.464365");
    return 0;
}

そして以下のように実行した。

g020@ubuntu-power1:~/ProgramExperiment$ gcc -g problem112a.c problem112a.s -o problem112.o
g020@ubuntu-power1:~/ProgramExperiment$ ./problem112.o
dot(2, &(double[]){-2.32, 23.3}, &(double[]){10.9, 2.5}) == 32.962000
ans 32.962
dot(0, NULL, NULL) == 0.000000
ans 0.0
dot(6, &(double[]){0.0783, 4.57, 13.1, -5.45, 9.60, 9.07}, &(double[]){-5.85, 0.397, 2.11, 4.04, 2.20, -3.48}) == -3.464365
ans -3.464365
